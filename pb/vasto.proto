syntax = "proto3";

package pb;

service VastoMaster {
    rpc RegisterStore (stream StoreHeartbeat) returns (stream StoreMessage) {
        // Stores send the heartbeat to Master
        // Master remembers the stores
        // and broadcast to all other stores and clients
    }

    rpc RegisterClient (stream ClientHeartbeat) returns (stream ClientMessage) {
        // Stores send the heartbeat to Master
        // Master remembers the stores
        // and broadcast to all other stores and clients
    }

    rpc Describe (DescribeRequest) returns (DescribeResponse) {
    }

    rpc CreateCluster (CreateClusterRequest) returns (CreateClusterResponse) {
    }

    rpc ResizeCluster (ResizeRequest) returns (stream ResizeProgress) {
    }

}

service VastoStore {
    rpc BootstrapCopy (BootstrapCopyRequest) returns (stream BootstrapCopyResponse) {
        /*
        client side
        1. if found local is out of sync with other nodes
            discard all local data and binlog offsets
        2. starts to copy
        3. stop when getting the binlog offset
        4. switch to pull changes mode
        5. tell master that this local node is ready

        server side
        1. get current binlog offset
        2. starts to stream data to client
        3. send the binlog offset from step 1
        */
    }
    rpc TailBinlog (PullUpdateRequest) returns (stream PullUpdateResponse) {
        // client pull data from server
    }
    rpc CheckBinlog (CheckBinlogRequest) returns (CheckBinlogResponse) {
        // client pull data from server
    }

    rpc CreateShard (CreateShardRequest) returns (CreateShardResponse) {
        // client pull data from server
    }

}

//////////////////////////////////////////////////
// 1. master received request to balance the data

//////////////////////////////////////////////////
// 1. master received request to balance the data
message BalanceRequest {
    string data_center = 1;
    string store_group = 2;
    uint32 store_count = 3; // 0 means to use all existing nodes. can not be more than existing stores.
}

message StoreMessage {
}

message ClientMessage {

    Cluster cluster = 1;

    message StoreResourceUpdate {
        repeated ClusterNode nodes = 1;
        bool is_delete = 2;
        string keyspace = 3;
    }
    StoreResourceUpdate updates = 2;

    message Resize {
        uint32 current_cluster_size = 1;
        uint32 next_cluster_size = 2;
        string keyspace = 3;
    }
    Resize resize = 3;

}

message Cluster {
    string keyspace = 1;
    string data_center = 2;
    repeated ClusterNode nodes = 3;
    uint32 expected_cluster_size = 4;
    uint32 current_cluster_size = 5;
    uint32 next_cluster_size = 6;
}

// denormalized
message ClusterNode {
    StoreResource store_resource = 1;
    ShardStatus shard_status = 2;
}

message StoreResource {
    string data_center = 1;
    string network = 2;
    string address = 3;
    string admin_address = 4;
    repeated string tags = 7;
    uint32 disk_size_gb = 8;
    uint32 allocated_size_gb = 9;
}

// StoreStatusInCluster is saved to and load from disk
message StoreStatusInCluster {
    uint32 id = 1;
    map<uint32, ShardStatus> shard_statuses = 2;
    // duplicated info, need to validate on master when reconvene
    uint32 cluster_size = 3;
    // duplicated info, need to validate on master when reconvene
    uint32 replication_factor = 4;
}

message ShardStatus {
    string keyspace_name = 1;
    uint32 node_id = 2;
    uint32 shard_id = 3;
    uint32 cluster_size = 4;
    uint32 replication_factor = 5;
    enum Status {
        EMPTY = 0;
        BOOTSTRAP = 1;
        READY = 2;
        DELETED = 3;
    }
    Status status = 6;
}

//////////////////////////////////////////////////
message StoreHeartbeat {
    // only in the initial heartbeat
    StoreResource store_resource = 1;
    // sent to master one at a time, after the initial heartbeat
    ShardStatus shardStatus = 2;
}

message ClientHeartbeat {
    string data_center = 1;
    string keyspace = 2;
}

message Empty {
}

//////////////////////////////////////////////////
//// data queries
//////////////////////////////////////////////////
message Requests {
    string keyspace = 1;
    repeated Request requests = 2;
}

message Responses {
    repeated Response responses = 1;
}

message Request {
    PutRequest put = 1;
    GetRequest get = 2;
    GetByPrefixRequest get_by_prefix = 3;
    DeleteRequest delete = 4;
}

message PutRequest {
    uint32 replica = 1;
    uint64 partition_hash = 2;
    KeyValue key_value = 3;
    uint32 ttl_second = 4;
}

message PutResponse {
    bool ok = 1;
    string status = 2;
}

message DeleteRequest {
    uint32 replica = 1;
    uint64 partition_hash = 2;
    bytes key = 3;
}

message DeleteResponse {
    bool ok = 1;
    string status = 2;
}

message GetRequest {
    uint32 replica = 1;
    bytes key = 2;
}

message GetResponse {
    bool ok = 1;
    string status = 2;
    KeyValue key_value = 3;
}

message GetByPrefixRequest {
    uint32 replica = 1;
    bytes prefix = 2;
    uint32 limit = 3;
    bytes last_seen_key = 4;
}

message GetByPrefixResponse {
    bool ok = 1;
    string status = 2;
    repeated KeyValue key_values = 3;
}

message Response {
    PutResponse put = 1;
    GetResponse get = 2;
    GetByPrefixResponse get_by_prefix = 3;
    DeleteResponse delete = 4;
}

message KeyValue {
    bytes key = 1;
    bytes value = 2;
}

//////////////////////////////////////////////////
//// data copying
//////////////////////////////////////////////////
message CopyDoneMessge {
    int32 shard = 1;
    int64 copy_start_time_ns = 2;
}

message BootstrapCopyRequest {
    string keyspace = 1;
    uint32 node_id = 2;
}
message BootstrapCopyResponse {

    repeated KeyValue key_values = 1;

    // this message is only sent at the end of copying
    message BinlogTailProgress {
        uint32 segment = 1;
        uint64 offset = 2;
    }
    BinlogTailProgress binlogTailProgress = 2;
}

message PullUpdateRequest {
    string keyspace = 1;
    uint32 node_id = 2;
    uint32 segment = 3;
    uint64 offset = 4;
    uint32 limit = 5;
}

message PullUpdateResponse {
    uint32 next_segment = 1;
    uint64 next_offset = 2;
    repeated UpdateEntry entries = 3;
    bool out_of_sync = 4;
}

message UpdateEntry {
    uint64 partition_hash = 3;
    uint64 updated_at_ns = 4;
    uint32 ttl_second = 5;
    uint32 crc = 6;
    bool isDelete = 7;
    bytes key = 8;
    bytes value = 9;
}

message CheckBinlogRequest {
    string keyspace = 1;
    uint32 node_id = 2;
}
message CheckBinlogResponse {
    uint32 node_id = 1;
    uint32 earliest_segment = 2;
    uint32 latest_segment = 3;
}
//////////////////////////////////////////////////
//// admin
//////////////////////////////////////////////////
message DescribeRequest {

    message DescDataCenters {
    }
    DescDataCenters desc_data_centers = 1;

    message DescKeyspaces {
    }
    DescKeyspaces desc_keyspaces = 2;

    message DescCluster {
        string keyspace = 1;
        string data_center = 2;
    }
    DescCluster desc_cluster = 3;

    message DescClients {
    }
    DescClients desc_clients = 4;

}
message DescribeResponse {
    message DescDataCenters {
        message DataCenter {
            string data_center = 1;
            repeated StoreResource store_resources = 2;
        }
        repeated DataCenter data_centers = 1;
    }
    DescDataCenters desc_data_centers = 1;

    message DescKeyspaces {
        message Keyspace {
            string keyspace = 1;
            repeated Cluster clusters = 2;
        }
        repeated Keyspace keyspaces = 1;
    }
    DescKeyspaces desc_keyspaces = 2;

    message DescCluster {
        Cluster cluster = 1;
    }
    DescCluster desc_cluster = 3;

    uint32 client_count = 4;
}

message CreateClusterRequest {
    string data_center = 1;
    string keyspace = 2;
    uint32 cluster_size = 3;
    uint32 replication_factor = 4;
    uint32 total_disk_size_gb = 5;
    repeated string tags = 6;
}

message CreateClusterResponse {
    string error = 1;
    Cluster cluster = 2;
}

message CreateShardRequest {
    string keyspace = 1;
    uint32 shard_id = 2;
    uint32 cluster_size = 3;
    uint32 replication_factor = 4;
    uint32 shard_disk_size_gb = 5;
}

message CreateShardResponse {
    string error = 1;
}

message ResizeRequest {
    string data_center = 1;
    string keyspace = 2;
    uint32 cluster_size = 3;
}
message ResizeProgress {
    string error = 1;
    string progress = 2;
    bool hasNotifiedClientsToStart = 3;
    bool hasNotifiedStoresToStart = 4;
    bool areStoresSplit = 5;
    bool areStoresReplicated = 6;
    bool areStoresCaughtUp = 7;
    bool hasNotifiedClientsToStop = 8;
    bool hasNotifiedStoresToStop = 9;
}
